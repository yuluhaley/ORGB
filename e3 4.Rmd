---
title: "e3"
output:
  pdf_document: default
  html_document: default
date: "2024-03-31"
---

```{r setup}
Sys.setenv(LANG = "en")
library(arrow)
library(readr)
data_path <- "C:/Users/chens/Desktop/orgb/"
applications <- read_parquet(paste0(data_path,"app_data_sample.parquet"))
edges <- read_csv(paste0(data_path,"edges_sample.csv"))
```



```{r applications}
applications
```



```{r edges}
edges
```
## Get gender for examiners

We’ll get gender based on the first name of the examiner, which is
recorded in the field `examiner_name_first`. We’ll use library `gender`
for that, relying on a modified version of their own
[example](https://cran.r-project.org/web/packages/gender/vignettes/predicting-gender.html).

Note that there are over 2 million records in the applications table –
that’s because there are many records for each examiner, as many as the
number of applications that examiner worked on during this time frame.
Our first step therefore is to get all *unique* names in a separate list
`examiner_names`. We will then guess gender for each one and will join
this table back to the original dataset. So, let’s get names without
repetition:
```{r gender}
library(gender)
library(dplyr)
# get a list of first names without repetitions
examiner_names <- applications %>% 
  distinct(examiner_name_first)

examiner_names
```

Now let’s use function `gender()` as shown in the example for the
package to attach a gender and probability to each name and put the
results into the table `examiner_names_gender`

```{r edges1}
library(tidyr)
# get a table of names and gender
examiner_names_gender <- examiner_names %>% 
  do(results = gender(.$examiner_name_first, method = "ssa")) %>% 
  unnest(cols = c(results), keep_empty = TRUE) %>% 
  select(
    examiner_name_first = name,
    gender,
    proportion_female
  )

examiner_names_gender
```

Finally, let’s join that table back to our original applications data
and discard the temporary tables we have just created to reduce clutter
in our environment.

```{r clean}
# remove extra colums from the gender table
examiner_names_gender <- examiner_names_gender %>% 
  select(examiner_name_first, gender)

# joining gender back to the dataset
applications <- applications %>% 
  left_join(examiner_names_gender, by = "examiner_name_first")

# cleaning up
rm(examiner_names)
rm(examiner_names_gender)
gc()
```

## Guess the examiner’s race

We’ll now use package `wru` to estimate likely race of an examiner. Just
like with gender, we’ll get a list of unique names first, only now we
are using surnames.

```{r wru}
library(wru)

examiner_surnames <- applications %>% 
  select(surname = examiner_name_last) %>% 
  distinct()

examiner_surnames
```



```{r race}
examiner_race <- predict_race(voter.file = examiner_surnames, surname.only = T) %>% 
  as_tibble()
```



```{r examrace}
examiner_race
```
As you can see, we get probabilities across five broad US Census
categories: white, black, Hispanic, Asian and other. (Some of you may
correctly point out that Hispanic is not a race category in the US
Census, but these are the limitations of this package.)

Our final step here is to pick the race category that has the highest
probability for each last name and then join the table back to the main
applications table. See this example for comparing values across
columns: <https://www.tidyverse.org/blog/2020/04/dplyr-1-0-0-rowwise/>.
And this one for `case_when()` function:
<https://dplyr.tidyverse.org/reference/case_when.html>.

```{r ra}
examiner_race <- examiner_race %>% 
  mutate(max_race_p = pmax(pred.asi, pred.bla, pred.his, pred.oth, pred.whi)) %>% 
  mutate(race = case_when(
    max_race_p == pred.asi ~ "Asian",
    max_race_p == pred.bla ~ "black",
    max_race_p == pred.his ~ "Hispanic",
    max_race_p == pred.oth ~ "other",
    max_race_p == pred.whi ~ "white",
    TRUE ~ NA_character_
  ))

examiner_race
```

Let’s join the data back to the applications table.
```{r join}
# removing extra columns
examiner_race <- examiner_race %>% 
  select(surname,race)

applications <- applications %>% 
  left_join(examiner_race, by = c("examiner_name_last" = "surname"))

rm(examiner_race)
rm(examiner_surnames)
gc()
```
## Examiner’s tenure

To figure out the timespan for which we observe each examiner in the
applications data, let’s find the first and the last observed date for
each examiner. We’ll first get examiner IDs and application dates in a
separate table, for ease of manipulation. We’ll keep examiner ID (the
field `examiner_id`), and earliest and latest dates for each application
(`filing_date` and `appl_status_date` respectively). We’ll use functions
in package `lubridate` to work with date and time values.

```{r dates}
library(lubridate) # to work with dates

examiner_dates <- applications %>% 
  select(examiner_id, filing_date, appl_status_date) 

examiner_dates
```
The dates look inconsistent in terms of formatting. Let’s make them
consistent. We’ll create new variables `start_date` and `end_date`.

```{r dates2}
examiner_dates <- examiner_dates %>% 
  mutate(start_date = ymd(filing_date), end_date = as_date(dmy_hms(appl_status_date)))
```

Let’s now identify the earliest and the latest date for each examiner
and calculate the difference in days, which is their tenure in the
organization.
```{r date3}
examiner_dates <- examiner_dates %>% 
  group_by(examiner_id) %>% 
  summarise(
    earliest_date = min(start_date, na.rm = TRUE), 
    latest_date = max(end_date, na.rm = TRUE),
    tenure_days = interval(earliest_date, latest_date) %/% days(1)
    ) %>% 
  filter(year(latest_date)<2018)

examiner_dates
```
Joining back to the applications data.
```{r joinback}
applications <- applications %>% 
  left_join(examiner_dates, by = "examiner_id")

rm(examiner_dates)
gc()
```



```{r merge}
library(dplyr)
 
# Merge the applications table with the edges table
merged_data <- edges %>%
  left_join(applications, by = "application_number")
 
# View the resulting merged data
colnames(merged_data)
```

```{r workgroup}
library(dplyr)
library(ggplot2)
library(igraph)
 

## 1. Select two workgroups based on the first 3 digits of `examiner_art_unit`. The variable examiner_art_unit is a string variable indicating the group art unit to which the examiner of record was assigned as of the last office action recorded for the application in question.

workgroup_1 <- merged_data %>%

  filter(substr(examiner_art_unit, 1, 3) == "164")
 
workgroup_2 <- merged_data %>%

  filter(substr(examiner_art_unit, 1, 3) == "242") 
 
# 2. Compare examiners' demographics between the two workgroups and show summary statistics and plots

# Calculate summary statistics for workgroup 1

summary_stats_1 <- workgroup_1 %>%

  group_by(gender, race) %>%

  summarise(count = n(), .groups = "drop")
 
# Calculate summary statistics for workgroup 2

summary_stats_2 <- workgroup_2 %>%

  group_by(gender, race) %>%

  summarise(count = n(), .groups = "drop")
 
# Plot demographics for workgroup 1

ggplot(summary_stats_1, aes(x = race, y = count, fill = gender)) +

  geom_bar(stat = "identity", position = "dodge") +

  labs(title = "Demographics of Workgroup 1")
 
# Plot demographics for workgroup 2

ggplot(summary_stats_2, aes(x = race, y = count, fill = gender)) +

  geom_bar(stat = "identity", position = "dodge") +

  labs(title = "Demographics of Workgroup 2")
 



```
```{r summary}
summary_stats_1
summary_stats_2

```


```{r edgenetwork}
#  create edge
# extract unique examiner ID
u_examiner_ids = unique(c(edges$ego_examiner_id, edges$alter_examiner_id))
 
# create data frame
vertices_df = data.frame(name = u_examiner_ids)
 
edges_all = edges %>%
  filter(ego_examiner_id %in% u_examiner_ids & alter_examiner_id %in% u_examiner_ids) %>%
  select(ego = ego_examiner_id, alter = alter_examiner_id)
 
# create the advice network graph with explicit vertices and edges
advice_network = graph_from_data_frame(d = edges_all, vertices = vertices_df, directed = TRUE)
plot(advice_network, main = "advice network")
edges_wg1 <- workgroup_1 %>%

  select(ego_examiner_id, alter_examiner_id)
 
edges_wg2 <- workgroup_2 %>%

  select(ego_examiner_id, alter_examiner_id)
 
# Create graph for workgroup 1&2

graph_wg1 <- graph_from_data_frame(d = edges_wg1, directed = TRUE)

graph_wg2 <- graph_from_data_frame(d = edges_wg2, directed = TRUE)

library(igraph)
 
# Plotting the network for Workgroup 1

plot(graph_wg1, main = "Network Graph for Workgroup 1")
 
# Plotting the network for Workgroup 2

plot(graph_wg2, main = "Network Graph for Workgroup 2")

 
# degree_centrality

degree_centrality_wg1 <- degree(graph_wg1, mode = "all")

degree_centrality_wg2 <- degree(graph_wg2, mode = "all")


# save degree_centrality in workgroup

workgroup_1$degree_centrality <- degree_centrality_wg1[match(workgroup_1$examiner_id, V(graph_wg1)$name)]

workgroup_2$degree_centrality <- degree_centrality_wg2[match(workgroup_2$examiner_id, V(graph_wg2)$name)]
workgroup_1$degree_centrality
workgroup_2$degree_centrality

```
Degree Centrality Justification: Degree centrality could be indicative of the workload and connectivity of an examiner within the advice network. An examiner with a high degree centrality may be involved in many patent cases and interact with many colleagues, which might impact the examination time and their mobility across units due to a potentially wider exposure to diverse cases.

Discuss relationship between degree centrality and other examiner's information
```{r tenure}
#Create a linear model of centrality based on tenure_days for workgroup 1
lm_wg1 <- lm(degree_centrality ~ tenure_days, data = workgroup_1)
summary(lm_wg1) # Outputs the summary of the linear model
# Repeat for workgroup 2
lm_wg2 <- lm(degree_centrality ~ tenure_days, data = workgroup_2)
summary(lm_wg2) # Outputs the summary of the linear model

# Visualize relationship between tenure_days and centrality
ggplot(workgroup_1, aes(x = tenure_days, y = degree_centrality)) +
  geom_point(alpha = 0.5) +
  geom_smooth(method = "lm", color = "blue") + # Linear regression line
  theme_minimal() +
  labs(title = "Centrality vs. Tenure Days in Workgroup 1", x = "Tenure Days", y = "Degree Centrality")
```
For Workgroup 1, the model shows a positive coefficient for `tenure_days` (0.03261), indicating that as tenure increases, so does centrality. This effect is statistically significant (p-value < 0.05), suggesting a significant positive correlation between tenure days and centrality within this group. However, the relatively low R-squared value (~1.4%) implies that tenure days only explain a small fraction of the variation in centrality scores.
 
For Workgroup 2, despite a positive coefficient for `tenure_days` (0.001170), the effect is not statistically significant (p-value = 0.359), indicating no strong evidence to support a significant impact of tenure days on centrality in this group. Moreover, the negative adjusted R-squared value (-0.0001008) suggests the model does not explain the centrality scores well compared to a baseline model.
 
Tenure appears to have a measurable but modest influence on centrality in Workgroup 1, suggesting that longer-tenured examiners may have more connections within the advice network. For Workgroup 2, tenure does not significantly affect centrality, hinting at other factors being more influential in determining an examiner's network position. These findings highlight the varied influence of tenure on professional networks across different groups, although the overall explanatory power of tenure alone is limited.

```{r gendercen}
library(ggplot2)
 
# Calculate average centrality score by gender

avg_centrality_by_gender <- workgroup_1 %>%

  group_by(gender) %>%

  summarise(average_centrality = mean(degree_centrality, na.rm = TRUE))
 
# Visualize with ggplot2

ggplot(avg_centrality_by_gender, aes(x = gender, y = average_centrality, fill = gender)) +

  geom_bar(stat = "identity") +

  theme_minimal() +

  labs(title = "Average Centrality by Gender in Workgroup 1", x = "Gender", y = "Average Centrality")

# Calculate average centrality score by gender

avg_centrality_by_gender <- workgroup_2 %>%

  group_by(gender) %>%

  summarise(average_centrality = mean(degree_centrality, na.rm = TRUE))
 
# Visualize with ggplot2

ggplot(avg_centrality_by_gender, aes(x = gender, y = average_centrality, fill = gender)) +

  geom_bar(stat = "identity") +

  theme_minimal() +

  labs(title = "Average Centrality by Gender in Workgroup 2", x = "Gender", y = "Average Centrality")

```
In Workgroup 1, male examiners have a higher average centrality score, indicating they might be more active within the network or play a more central role in knowledge and information exchange. Conversely, in Workgroup 2, female examiners boast a higher average centrality score. This shift could suggest variations in the dynamics of network interaction or the roles that different genders play in knowledge dissemination across different workgroups.

```{r racecen}
# Calculate average centrality score by race
avg_centrality_by_race <- workgroup_1 %>%
  group_by(race) %>%
  summarise(average_centrality = mean(degree_centrality, na.rm = TRUE))
 
# Visualize with ggplot2
ggplot(avg_centrality_by_race, aes(x = race, y = average_centrality, fill = race)) +
  geom_bar(stat = "identity") +
  theme_minimal() +
  labs(title = "Average Centrality by Race in Workgroup 1", x = "Race", y = "Average Centrality")
# Calculate average centrality score by race
avg_centrality_by_race <- workgroup_2 %>%
  group_by(race) %>%
  summarise(average_centrality = mean(degree_centrality, na.rm = TRUE))
 
# Visualize with ggplot2
ggplot(avg_centrality_by_race, aes(x = race, y = average_centrality, fill = race)) +
  geom_bar(stat = "identity") +
  theme_minimal() +
  labs(title = "Average Centrality by Race in Workgroup 2", x = "Race", y = "Average Centrality")
```

Regarding racial demographics, in Workgroup 1, Hispanic examiners are observed to occupy more peripheral positions within the advice network, indicating they might be less central to the flow of information or advice exchange. On the other hand, in Workgroup 2, Hispanic examiners have the highest average centrality score, suggesting a significant shift in their involvement and centrality in the network compared to Workgroup 1.

These observations may reflect the underlying dynamics of gender and racial participation within organizational networks. The differences in centrality by gender between Workgroup 1 and Workgroup 2 might point to the influence of workgroup-specific cultures or structures on gender roles within professional networks. Similarly, the varying centrality of racial groups across workgroups suggests that the inclusiveness and diversity of these networks can differ significantly, possibly due to varying organizational practices, cultural norms, or workgroup-specific dynamics. Understanding these patterns is crucial for developing strategies to promote a more inclusive and equitable environment within organizations.

